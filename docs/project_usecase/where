سازمان‌ها و شرکت‌ها

برای جلوگیری از افشای اطلاعات محرمانه (مثل اسم پروژه‌ها، پسوردها، شماره حساب‌ها).

برای اعمال سیاست‌های امنیتی سازمان (مثلاً کارمند اجازه نداشته باشه فایلی با کلمات مشخص ذخیره یا باز کنه).

مراکز داده و فایل‌سرورها

کنترل روی فایل‌های ذخیره‌شده در درایوهای اشتراکی.

جلوگیری از قرار گرفتن داده‌های حساس (PII یا مالی) در پوشه‌های عمومی.

محیط‌های توسعه نرم‌افزار

جلوگیری از باز شدن فایل‌هایی که شامل کلیدها و رمزهای API هستن.

محافظت از سورس‌کد و جلوگیری از خروج اطلاعات اختصاصی.



A) «اندازه دیتابیس کش: ۲MB vs ۱۰۰MB»

Endpoint: ۱۰۰MB منطقی و توصیه‌شده‌ست؛ هزینه دیسک ناچیزه و بهرهٔ UX/Performance بالاست.

File Server: حتی ۱–۲GB هم منطقیه. با ۲MB قطعاً درگیر eviction دائمی می‌شی و latency بالا می‌رود.

B) «بالای ۱۵MB رو اسکن نکنم؟»

Endpoint: بله؛ head-scan (۴–۸MB اول) + async full scan در پس‌زمینه؛ اگر match شد → از دفعه بعد Block.

File Server: نه؛ یا stream-scan کامل (chunked) یا Block تا پایان اسکن. «یک‌بار بازشدن» ریسکه.

C) «یک‌بار اجازه بده، بعداً چک کن»

Endpoint: ✅ (Allow-then-audit) مناسب و تجربهٔ کاربری خوب.

File Server: ❌ (Block-then-allow)؛ چون کاربر می‌تونه همان یک‌بار کپی کند و تمام.

D) الگوریتم Eviction

Endpoint: LRU + TTL (۷ روز) کافیست.

File Server: LRU + Priority bucket (پوشه‌های حساس با پین‌شدن)، به‌علاوه TTL کوتاه‌تر (۲–۳ روز) برای مسیرهای پر churn.

E) «تقریباً ۱۰۰٪ سیستم فایل را در کش داشته باشم»

Endpoint: شدنی و مفید (با invalidate صحیح).

File Server: به‌جای «همه‌جا»، کش را scope-aware کن (per-share/per-path) و برای مسیرهای عمومی TTL کوتاه‌تر بده.
